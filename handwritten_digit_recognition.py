# -*- coding: utf-8 -*-
"""Copy of Handwritten_Digit_Recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UmXqFU4RbO_U9RNRK0-AQ7evu9VjUxAm
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import tensorflow as tf
from tensorflow.keras.layers import Dense
from tensorflow.keras.models import Sequential
import seaborn as sns
import zipfile
import os
import os
import pandas as pd
from PIL import Image
import numpy as np

from google.colab import drive
drive.mount('/content/drive')

"""# Loading Dataset"""

with zipfile.ZipFile('archive.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/extracted_data')

dataset_path = '/content/extracted_data/dataset'

from PIL import Image
img = Image.open('/content/extracted_data/dataset/7/7/5192.png')
display(img)

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
def load_binary_image_flat(path, size=(28,28), threshold=None):
    img = Image.open(path)
    arr = np.array(img)
    barr = arr[:,:,3]
    #print(barr)
    print(barr.shape)   # shape = (28, 28, 4)
    print(barr.sum())
    if threshold is not None:
        barr = (barr > threshold).astype(np.uint8)
    return barr.flatten()

flat_vec = load_binary_image_flat(
    '/content/extracted_data/dataset/7/7/5192.png',
    size=(28,28),
    threshold=128
)
print(flat_vec.shape)
print(flat_vec.sum())

plt.imshow(flat_vec.reshape(28,28), cmap='binary')

from PIL import Image
import numpy as np
import pandas as pd
from pathlib import Path
import matplotlib.pyplot as plt

def load_binary_image_flat(path, size=(28,28),threshold=128):
    img = Image.open(path)
    arr = np.array(img)
    barr = arr[:, :, 3]
    #print(barr)
    #print(barr.shape)
    #print(barr.sum())
    if threshold is not None:
        barr = (barr > threshold).astype(np.uint8)
    return barr.flatten()

root = Path('/content/extracted_data/dataset')
data, labels = [], []

for digit_dir in sorted(root.iterdir()):
    if not digit_dir.is_dir():
        continue
    label = int(digit_dir.name)
    for img_path in digit_dir.rglob('*.png'):
        vec = load_binary_image_flat(str(img_path))
        data.append(vec)
        labels.append(label)

plt.imshow(data[20].reshape(28,28), cmap='binary')
print(labels[20])

df = pd.DataFrame(data)
df['label'] = labels

print("DataFrame shape:", df.shape)

df.head()

pixel_cols = df.columns[:-1]

norm_df=df

X = df[pixel_cols]
y = df['label']
print("X shape:", X.shape)
print("y shape:", y.shape)

"""# TensorFlow Model

**üìÑ Dataset Description: Handwritten Digits Dataset (Non-MNIST)**

*  The dataset used in this project is a custom handwritten digits dataset sourced from Kaggle, distinct from the widely used MNIST dataset.
*   It consists of grayscale images of handwritten digits from 0 to 9, organized into class-specific folders. Each digit class is stored inside a folder named after the corresponding digit (0, 1, ..., 9).

*  üìê Dataset Statistics

| Attribute                  | Value                     |
|---------------------------|---------------------------|
| Total datapoints (images) | **107,730**               |
| Image size                | **28√ó28** pixels          |
| Number of features        | **784** (28√ó28 flattened) |
| Total classes             | **10** (digits 0‚Äì9)       |
| Data format               | **Pandas DataFrame**      |
| Input shape (X)           | **(107730, 784)**         |
| Label shape (y)           | **(107730,)**             |
| Data type                 | **uint8** (0‚Äì255 values)  |
"""

import matplotlib.pyplot as plt
import numpy as np
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

m, n = X.shape

fig, axes = plt.subplots(8, 8, figsize=(8, 8))
fig.tight_layout(pad=0.13, rect=[0, 0.03, 1, 0.91])

for i, ax in enumerate(axes.flat):
    random_index = np.random.randint(m)

    image = X.iloc[random_index].values.reshape(28, 28)

    ax.imshow(image, cmap='binary')

    ax.set_title(str(y.iloc[random_index]), fontsize=6)
    ax.set_axis_off()

fig.suptitle("Label, image", fontsize=14)
plt.show()

#norm_df[pixel_cols] = norm_df[pixel_cols].astype(np.float32) / 255.0

X_norm=norm_df[pixel_cols]
y=norm_df['label']

from sklearn.manifold import TSNE
import seaborn as sns

tsne = TSNE(n_components=2, random_state=42)
X_embedded = tsne.fit_transform(X.sample(2000))  # Sample for speed
sns.scatterplot(x=X_embedded[:,0], y=X_embedded[:,1], hue=y.sample(2000), palette='tab10', legend='full')
plt.title("t-SNE Projection of Handwritten Digits")
plt.show()

"""‚ú® **t-SNE Visualization Description**

The above t-SNE plot represents a 2D projection of the original high-dimensional handwritten digit images (28√ó28 pixels = 784 features) into two dimensions while preserving the local structure of the data.  

Each point in the plot corresponds to one image from the dataset, and the color of each point indicates its associated digit class (0‚Äì9).

From the plot:
- **Clusters** of points belonging to the same digit class can be observed, suggesting that similar handwritten digits are placed close to each other in the high-dimensional space.
- Some **overlapping regions** exist where different digit classes (e.g., 3 and 5, or 4 and 9) are mixed together. This indicates that certain digits may share similar visual features and could be harder for a model to distinguish.
- **Separation** between easily distinguishable digits like "0" and "1" is more prominent.

Overall, this visualization provides an intuitive understanding of how the digits are distributed and how separable different classes are, which is valuable for evaluating the expected performance of classification models.

---

üî• **Insight**

**"The t-SNE plot shows that while many handwritten digits form well-defined clusters, some classes overlap, suggesting potential challenges in classification."**

"""

import tensorflow as tf
from tensorflow.keras.layers import Dense,Conv2D,MaxPooling2D,Flatten
from tensorflow.keras.models import Sequential
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X_norm, y, test_size=0.2, random_state=42,stratify=y)

tf.random.set_seed(1234)
model=Sequential([
    tf.keras.Input(shape=(784,)),
    tf.keras.layers.Reshape((28,28,1)),
    Conv2D(64,(3,3),activation='relu',input_shape=(28,28,1)),
    MaxPooling2D(),
    Conv2D(32,3,padding='same',activation='relu'),
    MaxPooling2D(),
    Conv2D(16, 3, padding='same', activation='relu'),
    MaxPooling2D(),
    Conv2D(64, 3, padding='same', activation='relu'),
    MaxPooling2D(),
    Flatten(),
    Dense(64,activation='relu'),
    Dense(10,activation='linear')
],name='my_model')
model.summary()

model.compile(
    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
    metrics=['accuracy']
)

callback=tf.keras.callbacks.EarlyStopping(monitor='val_loss',patience=3,restore_best_weights=True)

history=model.fit(
    X_train,y_train,
    validation_split=0.1,
    epochs=15,
    batch_size=64,
    verbose=1,
    callbacks=[callback]
)

import pickle
pickle.dump(model, open('/content/drive/MyDrive/Colab Notebooks/handwritten_conv.pkl', 'wb'))

train_loss, train_acc = model.evaluate(X_train, y_train, verbose=0)
print(f"Train Accuracy: {train_acc:.4f}")

epochs = range(1, len(history.history['loss']) + 1)

plt.figure(figsize=(14,5))

# Accuracy Plot
plt.subplot(1, 2, 1)
plt.plot(epochs, history.history['accuracy'], label='Train Accuracy')
plt.plot(epochs, history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Accuracy Over Epochs')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.grid(True)

# Loss Plot
plt.subplot(1, 2, 2)
plt.plot(epochs, history.history['loss'], label='Train Loss')
plt.plot(epochs, history.history['val_loss'], label='Validation Loss')
plt.title('Loss Over Epochs')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

test_loss, test_accuracy = model.evaluate(X_test, y_test, verbose=1)
print(f"Test Accuracy: {test_accuracy:.4f}")

logits = model.predict(X_test)
y_pred = tf.argmax(logits, axis=1).numpy()

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt

cm = confusion_matrix(y_test, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=np.arange(10))

plt.figure(figsize=(8, 6))
disp.plot(cmap='Blues', values_format='d')
plt.title("Confusion Matrix on Test Data")
plt.show()

"""# Real Time Prediction"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

def preprocess_image(path, target_size=(28, 28)):
    img = Image.open(path).convert('L')

    img = img.resize(target_size)

    img = np.array(img)
    #img = 255 - img
    img = (img < 128).astype(np.uint8)

    img = img.reshape(1, 28*28)
    #plt.imshow(img, cmap='gray')

    return img

img_array = preprocess_image('1.jpg')
print(img_array.sum())

plt.imshow(img_array.reshape(28,28), cmap='binary')
plt.show()

logits = model.predict(img_array)
prediction = np.argmax(logits)
print(f"Predicted Digit: {prediction}")